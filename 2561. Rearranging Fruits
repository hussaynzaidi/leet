typedef struct {
    int key;
    int count;
    UT_hash_handle hh;
} Hash;

void add(Hash **map, int key, int delta) {
    Hash *entry;
    HASH_FIND_INT(*map, &key, entry);
    if (!entry) {
        entry = (Hash *)malloc(sizeof(Hash));
        entry->key = key;
        entry->count = 0;
        HASH_ADD_INT(*map, key, entry);
    }
    entry->count += delta;
}

void free_map(Hash **map) {
    Hash *e, *tmp;
    HASH_ITER(hh, *map, e, tmp) {
        HASH_DEL(*map, e);
        free(e);
    }
}

int cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }

long long minCost(int *basket1, int basket1Size, int *basket2,
                  int basket2Size) {
    int m = INT_MAX;
    Hash *frequency_map = NULL;
    for (int i = 0; i < basket1Size; i++) {
        add(&frequency_map, basket1[i], 1);
        if (basket1[i] < m) m = basket1[i];
    }
    for (int i = 0; i < basket2Size; i++) {
        add(&frequency_map, basket2[i], -1);
        if (basket2[i] < m) m = basket2[i];
    }

    int *merge = (int *)malloc(sizeof(int) * (basket1Size + basket2Size));
    int mergeSize = 0;
    Hash *e, *tmp;
    HASH_ITER(hh, frequency_map, e, tmp) {
        int c = e->count;
        if (c % 2 != 0) {
            free(merge);
            free_map(&frequency_map);
            return -1;
        }
        for (int i = 0; i < abs(c) / 2; i++) {
            merge[mergeSize++] = e->key;
        }
    }

    if (mergeSize == 0) {
        free(merge);
        free_map(&frequency_map);
        return 0;
    }

    qsort(merge, mergeSize, sizeof(int), cmp);

    long long res = 0;
    for (int i = 0; i < mergeSize / 2; i++) {
        res += fmin(merge[i], m * 2);
    }

    free(merge);
    free_map(&frequency_map);
    return res;
}
