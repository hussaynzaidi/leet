#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int cmp(const void* a, const void* b) {
    return (*(int*)a) - (*(int*)b);
}

// Remove duplicates from sorted array
int dedup(int* arr, int size) {
    if (size == 0) return 0;
    int j = 1;
    for (int i = 1; i < size; ++i) {
        if (arr[i] != arr[i - 1]) {
            arr[j++] = arr[i];
        }
    }
    return j;
}

int subarrayBitwiseORs(int* A, int ASize) {
    int* result = malloc(sizeof(int) * ASize * 30);  // worst-case upper bound
    int resultSize = 0;

    int* prev = malloc(sizeof(int) * 1000);  // holds last ORs
    int prevSize = 0;

    for (int i = 0; i < ASize; ++i) {
        int* curr = malloc(sizeof(int) * 1000);
        int currSize = 0;

        curr[currSize++] = A[i];
        for (int j = 0; j < prevSize; ++j) {
            curr[currSize++] = A[i] | prev[j];
        }

        // sort and deduplicate current ORs
        qsort(curr, currSize, sizeof(int), cmp);
        currSize = dedup(curr, currSize);

        // add to result if not already present
        for (int j = 0; j < currSize; ++j) {
            result[resultSize++] = curr[j];
        }

        // dedup result array after all insertions
        if (i == ASize - 1) {
            qsort(result, resultSize, sizeof(int), cmp);
            resultSize = dedup(result, resultSize);
        }

        // swap curr -> prev
        free(prev);
        prev = curr;
        prevSize = currSize;
    }

    free(prev);
    free(result);  // not returning it; just return size
    return resultSize;
}
